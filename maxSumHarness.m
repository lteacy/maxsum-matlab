function [err,maxSumArgMax,stdMaxArg] = maxSumHarness(depth,branchfactor)
% MAXSUMHARNESS Checks maxSum for consistency with the max on acyclic factor
% graph.
% Usage: err = maxSumHarness(depth,branchfactor);
%
% where
%        depth - depth of factor graph tree
% branchfactor - branching factor of factor graph tree
%          err - difference between the maximum calculated by maxsum and the
%                standard max function.
%
% Usage: [err, msArgMax, mxArgMax] = maxSumHarness(...);
% Also returns the argmax generated by maxsum (msArgMax) and by the
% standard max function.
%
% Warning: Since this function compares against the max functon, called for
% the global reward function, only small depth and branch factors are
% allowed to avoid the process hanging.
%
% Known issues: The function for generating test tree graphs isn't quite right,
% so may give an error in some cases.
%

%******************************************************************************
%  Generate a random problem and its single aggregate reward
%******************************************************************************
  graph = genTreeGraph(depth,branchfactor);
rewards = genRewards(graph);

globalReward = sumFun(rewards);
globalReward = globalReward{1};
domain = size(globalReward);

%******************************************************************************
%  Solve using max-sum
%******************************************************************************
maxSumArgMax = maxSum(rewards);
maxSumArgMaxCell = num2cell(maxSumArgMax);
maxSumMaxVal = globalReward.data(maxSumArgMaxCell{:});

%******************************************************************************
%  Solve using standard max
%******************************************************************************
[stdMaxVal, stdInd] = max(globalReward.data(:));
stdMaxArg = cell(1,numel(domain));
[stdMaxArg{:}] = ind2sub(domain,stdInd);
stdMaxArg = [stdMaxArg{:}];

%******************************************************************************
%  Test Max-Marginal result
%******************************************************************************
maxMarginalResult = maxMarginal(globalReward,globalReward.dims);
maxMarginalResult = maxMarginalResult.data;

%******************************************************************************
%  Display Result
%******************************************************************************
err = stdMaxVal-maxSumMaxVal;
fprintf('max-sum error: %f\n',stdMaxVal-maxSumMaxVal);
fprintf('maxMarg error: %f\n',stdMaxVal-maxMarginalResult);
fprintf('max std value: %f\n',stdMaxVal);
disp(' ');
%disp('argmax:');
%disp([maxSumArgMax; stdMaxArg; double(maxSumArgMax~=stdMaxArg)]);

%*****************************************************************************
%*****************************************************************************
%  Generate random reward functions from graph
%*****************************************************************************
%*****************************************************************************
function rewards = genRewards(graph)

ACTION_DOMAIN = 2;

problemSize = log(ACTION_DOMAIN)*size(graph,2)/log(2);
fprintf('problem size: %f\n',problemSize);
if 20<problemSize
   error('The problem is too big');
end

rewards = cell(1,size(graph,1));
for it=1:numel(rewards)

   vars = find(graph(it,:));
   domain = ACTION_DOMAIN*ones(1,numel(vars));
   data = 10*rand([domain 1]);
   func = msfun(vars,data);
   rewards{it} = func;

end

%*****************************************************************************
%*****************************************************************************
%     Private function for generating a tree of regions
%*****************************************************************************
%*****************************************************************************
function [graph, noNodes]=genTreeGraph(depth,branchfactor)


noNodes = sum(branchfactor.^(0:depth)); % same no. actions, states & regions
nodeIds = 1:noNodes;


if isequal(branchfactor,1)
   relation = [nodeIds nodeIds(1:(noNodes-1)); ...
               nodeIds nodeIds(2:end)];
   
   graph = sparse(relation(1,:),relation(2,:),true,noNodes,noNodes);
   return;
end


levels = floor(log(nodeIds)/log(branchfactor));
offsets = branchfactor.^levels;
levelIds = nodeIds-offsets;
rootIds = floor(levelIds(2:end)/branchfactor) ...
              + branchfactor.^(levels(2:end)-1);

relation = [nodeIds(2:end) rootIds; rootIds nodeIds(2:end)];

graph = sparse(relation(1,:),relation(2,:),true,noNodes,noNodes);

